import { CommonConstants as Const } from '../common/constants/CommonConstants';
import { isReachNewAchievement, ACHIEVEMENT_LEVEL_KEY , updateTaskOvertimeLevel} from '../model/AchieveModel';
import { TaskMapById, ITaskItem, ACHIEVEMENT_LEVEL_LIST } from '../model/TaskInitList';
import TaskInfo from './TaskInfo';

import DayInfo from './DayInfo';
import { dateToStr, weekDateFormat } from '../common/utils/Utils';
import { WeekDateModel, initializeOnStartUp, getPreviousWeek, getCurMonth, WEEK_DAY_NUM } from '../model/WeekCalendarModel';
import DatabaseApi from '../model/DatabaseModel';
import TaskInfoTableApi from '../common/database/tables/TaskInfoApi';
import DayInfoApi from '../common/database/tables/DayInfoApi';
import GlobalInfoApi from '../common/database/tables/GlobalInfoApi';
import Logger from '../common/utils/Logger';
import GlobalInfo from './GlobalInfo';
import WeekCalendarInfo from './WeekCalendarInfo';
import AchievementInfo from './AchievementInfo';

@Observed
export class HomeStore {
  public currentDate: Date;
  public dateArr: Array<WeekDateModel> = []; // data source list
  public monthArr: WeekDateModel[][] = [];
  public selectedDay: number; // selected day of on week
  public showDate: number;
  public dateTitle: string;
  public selectedDayInfo: WeekDateModel = new WeekDateModel('', '', new Date()); // task info on selected day

  constructor(currentDate: Date) {
    this.currentDate = currentDate;
    this.showDate = currentDate.getTime();
    this.dateTitle = weekDateFormat(currentDate.getTime());
    this.selectedDay = (new Date().getDay() + WEEK_DAY_NUM - 1) % WEEK_DAY_NUM;
  }

  public initData() {
    let weekCalendarInfo: WeekCalendarInfo = initializeOnStartUp(this.currentDate);
    this.dateArr = weekCalendarInfo.arr;
    Logger.info('this.currentDate', this.currentDate.toDateString());
    Logger.info('initWeekData dateArr', JSON.stringify(weekCalendarInfo.strArr))
    // get data form db
    DatabaseApi.query(dateToStr(new Date()), (taskList: TaskInfo[], dayInfo: DayInfo) => {
      Logger.info('Current Day Task Info: ', JSON.stringify(taskList));
      DayInfoApi.queryList(weekCalendarInfo.strArr, (res: DayInfo[]) => {
        let tempList = res.concat(dayInfo);
        Logger.info('initDayInfoList: ', JSON.stringify(res));
        for (let i = 0; i < this.dateArr.length; i++) {
          let tempDayInfo = tempList.find((item: DayInfo) => item.date === this.dateArr[i].dateStr) || new DayInfo(this.dateArr[i].dateStr, 0, 0);
          weekCalendarInfo.arr[i].dayInfo = tempDayInfo;
          if (this.dateArr[i].dateStr === dateToStr(new Date(this.showDate))) {
            // get tasks of showDate
            weekCalendarInfo.arr[i].taskList = taskList;
          }
        }
        this.dateArr = weekCalendarInfo.arr;
        setTimeout(() => {
          this.setSelectedShowDate(this.showDate);
        }, 0)
      })
    })
  }

  public getPreWeekData(date: Date, callback: Function) {
    let weekCalendarInfo: WeekCalendarInfo = getPreviousWeek(date);
    // get data form db
    DayInfoApi.queryList(weekCalendarInfo.strArr, (res: DayInfo[]) => {
      Logger.info('getPreWeekData->DayInfoList: ', JSON.stringify(res));
      if (res.length > 0) {
        for (let i = 0; i < weekCalendarInfo.arr.length; i++) {
          let dayInfo = res.find((item) => item.date === weekCalendarInfo.arr[i].dateStr);
          if (dayInfo) {
            weekCalendarInfo.arr[i].dayInfo = dayInfo;
          }
        }
      }
      this.dateArr = weekCalendarInfo.arr.concat(...this.dateArr);
      callback();
    })
  }

  public loadMonthData(date: Date, callback: Function) {
    // å…ˆç”¨ getCurMonth æ‹¿åˆ°æŒ‰å‘¨åˆ†ç»„çš„æœ¬æœˆæ•°æ®
    let monthWeeks: WeekDateModel[][] = getCurMonth(date);

    // æ‰å¹³åŒ–æˆä¸€ç»´æ•°ç»„ï¼Œæ–¹ä¾¿å¤„ç†
    let allDays: WeekDateModel[] = monthWeeks.flat();

    // æå–æ‰€æœ‰æ—¥æœŸå­—ç¬¦ä¸²ï¼Œå‡†å¤‡å»æ•°æ®åº“æŸ¥è¯¢
    let dateStrArr: string[] = allDays.map(item => {
      return item.dateStr;
    });

    // è°ƒç”¨æ¥å£æŸ¥è¯¢å¯¹åº”çš„ DayInfo
    DayInfoApi.queryList(dateStrArr, (res: DayInfo[]) => {
      Logger.info('getCurMonthData->DayInfoList: ', JSON.stringify(res));

      // æŠŠæŸ¥è¯¢ç»“æœå›å¡«è¿› allDays
      if (res.length > 0) {
        for (let i = 0; i < allDays.length; i++) {
          let dayInfo = res.find(item => item.date === allDays[i].dateStr);
          if (dayInfo) {
            allDays[i].dayInfo = dayInfo;
          }
        }
      }

      // å›å¡«åˆ° monthWeeks çš„äºŒç»´ç»“æ„ä¸­
      let index = 0;
      for (let w = 0; w < monthWeeks.length; w++) {
        for (let d = 0; d < monthWeeks[w].length; d++) {
          monthWeeks[w][d] = allDays[index++];
        }
      }

      // æ›´æ–°åˆ° ViewModelï¼ˆå‡è®¾ä½ æœ‰ monthArr å­˜å‚¨ï¼‰
      this.monthArr = monthWeeks;

      // è°ƒç”¨å›è°ƒ
      callback();
    });
  }

  // check is current day
  public checkCurrentDay(): boolean {
    return dateToStr(new Date()) === this.selectedDayInfo?.dateStr;
  }

  public updateSelectedDayInfo(selectedDayInfo: WeekDateModel) {
    Logger.debug('updateSelectedDayInfo', JSON.stringify(selectedDayInfo));
    if (selectedDayInfo.taskList?.length === 0) {
      // get data form db
      TaskInfoTableApi.query(selectedDayInfo.dateStr, true, (res: TaskInfo[]) => {
        Logger.info('Selected TaskInfoList: ', JSON.stringify(res));
        selectedDayInfo.taskList = res;
        this.dateArr = this.dateArr.map((item: WeekDateModel) => {
          if(item.dateStr === selectedDayInfo.dateStr) {
            let taskListStr = JSON.stringify(res);
            item.taskList = JSON.parse(taskListStr);
            return item;
          } else {
            return item;
          }
        })
        this.selectedDayInfo = selectedDayInfo;
      });
    } else {
      this.selectedDayInfo = selectedDayInfo;
    }
    Logger.info("selectedDayTaskInfo: ", JSON.stringify(selectedDayInfo.taskList));
  }

  public updateTaskInfoList(editedTaskInfo: ITaskItem) {
    if (editedTaskInfo?.taskID) {
      // edited task
      let taskID = editedTaskInfo.taskID;
      let targetValue = editedTaskInfo.targetValue;
      // è®¾ç½®åˆå§‹å®Œæˆå€¼
      let finValue:string;
      switch (taskID) {
        case 2:
          finValue = '0.00';
          break;
        case 3:
        case 4:
        case 5:
        case 7:
          finValue = '0';
          break;
        default:
          finValue = '';
      }
      let isAlarm = editedTaskInfo.isAlarm;
      let frequency = editedTaskInfo.frequency;
      let startTime = editedTaskInfo.startTime;
      let endTime = editedTaskInfo.endTime;
      let isOpen = editedTaskInfo.isOpen;
      let task = new TaskInfo(0, dateToStr(new Date()), taskID, targetValue, isAlarm,
        startTime, endTime, frequency, false, finValue, isOpen);
      this.dateArr = this.dateArr.map((item: WeekDateModel) => {
        if (task.date === item.dateStr) {
          Logger.info('item', JSON.stringify(item));
          let taskList: TaskInfo[] = item.taskList;
          const dayInfo: DayInfo = item.dayInfo;
          if (editedTaskInfo.isOpen) {
            // add task
            taskList = taskList.filter((taskItem) => taskItem.taskID != taskID)
              .concat(task)
              .sort((a, b) => a.taskID - b.taskID);
            let count: number = 0;
            taskList.forEach((taskItem: TaskInfo) => {
              if (taskItem.isDone) {
                count++;
              }
            });
            if (count > dayInfo.finTaskNum) {
              dayInfo.finTaskNum = count;
            }
          } else {
            // delete task
            let taskIndex = taskList.findIndex((taskItem) => taskItem.taskID === taskID);
            Logger.info('taskList[taskIndex]', JSON.stringify(taskList[taskIndex]));
            if (taskList[taskIndex]?.isDone) {
              dayInfo.finTaskNum -= 1;
            }
            taskList = taskList.filter((taskItem) => taskItem.taskID != taskID);
          }
          dayInfo.targetTaskNum = taskList.length;
          if (dayInfo.finTaskNum > dayInfo.targetTaskNum) {
            dayInfo.finTaskNum = dayInfo.targetTaskNum;
          }
          DayInfoApi.updateData(dayInfo, () => {
          });
          Logger.debug("tempDayInfo", JSON.stringify(dayInfo));
          let weekDateModelStr = JSON.stringify(item);
          let currentDayInfo: WeekDateModel = JSON.parse(weekDateModelStr);
          currentDayInfo.date = item.date;
          currentDayInfo.taskList = taskList;
          currentDayInfo.dayInfo = dayInfo;
          if (this.checkCurrentDay()) {
            this.selectedDayInfo = currentDayInfo;
          }
          return currentDayInfo;
        }
        return item;
      }).slice(0);
    }
  }

  public setSelectedShowDate(showDateTime: number) {
    if (showDateTime > new Date().getTime()) {
      return;
    }
    this.showDate = showDateTime;
    this.dateTitle = weekDateFormat(this.showDate);
    let selectedInfo = this.dateArr.find((item: WeekDateModel) => item.dateStr === dateToStr(new Date(showDateTime)));
    if (selectedInfo) {
      this.updateSelectedDayInfo(selectedInfo);
    }
    Logger.info('dateTitle', this.dateTitle);
  }

  public getDonePercent(): string {
    let dayInfo = this.selectedDayInfo?.dayInfo;
    Logger.debug("dayInfo", JSON.stringify(dayInfo));
    if (dayInfo && (dayInfo?.finTaskNum || 0) > 0) {
      if (dayInfo.finTaskNum > dayInfo.targetTaskNum) {
        return `${Const.DEFAULT_100}`;
      }
      return `${Math.ceil(dayInfo.finTaskNum / dayInfo.targetTaskNum * Const.DEFAULT_100)}`;
    }
    return '0';
  }

  public getTaskListOfDay(): TaskInfo[] {
    Logger.info('getTaskListOfDay', JSON.stringify(this.selectedDayInfo));
    if (this.selectedDayInfo && this.selectedDayInfo.taskList.length > 0) {
      return this.selectedDayInfo.taskList;
    }
    return [];
  }
  // âœ… æ–°å¢ï¼šæ£€æµ‹è¶…é‡å®Œæˆçš„æ–¹æ³•
  // private checkOvertimeCompletion(taskItem: TaskInfo): number {
  private checkOvertimeCompletion(taskItem: TaskInfo): number []{

    console.log('--- è¶…é‡æ£€æµ‹è¯¦æƒ… ---');
    console.log(`ä»»åŠ¡ID: ${taskItem.taskID}`);
    console.log(`å®Œæˆå€¼: ${taskItem.finValue}`);
    console.log(`ç›®æ ‡å€¼: ${taskItem.targetValue}`);

    const fin = Number(taskItem.finValue);
    const target = Number(taskItem.targetValue);

    console.log(`è½¬æ¢å - å®Œæˆå€¼: ${fin}, ç›®æ ‡å€¼: ${target}`);

    // åªæ£€æµ‹æ•°å€¼ç±»å‹çš„ä»»åŠ¡
    if (isNaN(fin) || isNaN(target) || target <= 0) {
      console.log('âŒ éæ•°å€¼ä»»åŠ¡æˆ–ç›®æ ‡å€¼æ— æ•ˆï¼Œä¸æ£€æµ‹è¶…é‡');
      // return 0;
      return [];
    }


    const completionRatio = fin / target;
    console.log(`å®Œæˆæ¯”ä¾‹: ${completionRatio.toFixed(2)} (${(completionRatio * 100).toFixed(1)}%)`);

    // æ ¹æ®å®Œæˆæ¯”ä¾‹è¿”å›ä¸åŒçš„æˆå°±ç­‰çº§
    let achievedLevels: number[] = [];

    if (completionRatio == 2.0) {
      achievedLevels.push(200);
      console.log(' ğŸ¥ˆ è¾¾åˆ° 200% æˆå°±ï¼');
    }

    if (completionRatio == 4.0) {
      achievedLevels.push(400);
      console.log('ğŸ¥‡ è¾¾åˆ° 400% æˆå°±ï¼');
    }

    if (completionRatio >= 10.0) {
      achievedLevels.push(1000);
      console.log('ğŸ† è¾¾åˆ° 1000% éå‡¡å¤§å¸ˆ æˆå°±ï¼');
    }

    console.log('è¾¾åˆ°çš„æ‰€æœ‰ç­‰çº§:', achievedLevels);
    return achievedLevels;
  }

  public async taskClock(taskInfo: TaskInfo) {
    let taskItem = await this.updateTask(taskInfo);
    let dateStr = this.selectedDayInfo?.dateStr;
    if (!taskItem) {
      return {
        achievementLevel: 0,
        showAchievement: false
      } as AchievementInfo;
    }
    // æ£€æµ‹è¶…é‡å®Œæˆ
    // let overtimeAchievement: number = 0;
    let overtimeAchievements: number[] = [];  // æ”¹ä¸ºæ•°ç»„
    let maxOvertimeLevel = 0;
    if (taskItem.isDone) {
      console.log('=== æ£€æµ‹è¶…é‡å®Œæˆ ===');
      overtimeAchievements = this.checkOvertimeCompletion(taskItem);
      if (overtimeAchievements.length > 0) {
        
        for (let level of overtimeAchievements) {
          updateTaskOvertimeLevel(taskItem.taskID, level);
        }
        // è·å–æœ€é«˜ç­‰çº§ç”¨äºå¼¹çª—æ˜¾ç¤º
        maxOvertimeLevel = Math.max(...overtimeAchievements);
        console.log(`ä»»åŠ¡${taskItem.taskID}è¶…é‡å®Œæˆï¼è¾¾åˆ°ç­‰çº§: ${overtimeAchievements.join(', ')}`);
        Logger.info(`ä»»åŠ¡${taskItem.taskID}è¶…é‡å®Œæˆï¼è¾¾åˆ°ç­‰çº§: ${overtimeAchievements.join(', ')}`);
      } else {
        console.log(`ä»»åŠ¡${taskItem.taskID}æ­£å¸¸å®Œæˆï¼Œæ— è¶…é‡æˆå°±`);
      }
    }
    this.selectedDayInfo.taskList = this.selectedDayInfo.taskList.map((item) => {
      return item.taskID === taskItem?.taskID ? taskItem : item;
    });
    // æ£€æŸ¥è¿ç»­æ‰“å¡æˆå°±
    let achievementLevel: number = 0;
    if (taskItem.isDone) {
      let dayInfo = await this.updateDayInfo();
      if (dayInfo && dayInfo?.finTaskNum === dayInfo?.targetTaskNum) {
        achievementLevel = await this.updateAchievement(this.selectedDayInfo.dayInfo);
        // ç‰¹æ®Šå¤„ç†ï¼šè¿ç»­1å¤©æ‰“å¡æˆåŠŸ
        if (achievementLevel === 1) {
          console.log('é¦–æ¬¡æ‰“å¡æˆåŠŸï¼æ˜¾ç¤ºç‰¹æ®Šå¼¹çª—');
        }
      }
    }


    this.dateArr = this.dateArr.map((item: WeekDateModel) => dateStr === item.dateStr ? this.selectedDayInfo : item);
    // âœ… ä¿®æ”¹ï¼šä¼˜å…ˆæ˜¾ç¤ºè¶…é‡æˆå°±ï¼Œå¦åˆ™æ˜¾ç¤ºè¿ç»­æ‰“å¡æˆå°±
    const finalAchievementLevel = maxOvertimeLevel > 0 ? maxOvertimeLevel : achievementLevel;
    const shouldShowAchievement = maxOvertimeLevel > 0 || ACHIEVEMENT_LEVEL_LIST.includes(achievementLevel);


    return {
      achievementLevel: finalAchievementLevel,
      showAchievement: shouldShowAchievement,
      isFirstDay: achievementLevel === 1
    } as AchievementInfo;
  }

  updateTask(task: TaskInfo): Promise<TaskInfo> {
    return new Promise((resolve, reject) => {
      let taskID = task.taskID;
      let targetValue = task.targetValue;
      let finValue = task.finValue;
      let updateTask = new TaskInfo(task.id, task.date, taskID, targetValue, task.isAlarm, task.startTime,
        task.endTime, task.frequency, task.isDone, finValue, task.isOpen);
      let step = TaskMapById[taskID - 1].step;

      if (step === 0) {
        // ä¸€æ¬¡æ€§ä»»åŠ¡ï¼šç‚¹å‡»ä¸€æ¬¡å°±å®Œæˆ
        updateTask.isDone = true;
        updateTask.finValue = targetValue;
      } else {
        // æ•°å€¼ç´¯åŠ ä»»åŠ¡ï¼šæ”¯æŒè¶…é‡å®Œæˆ
        let value = Number(finValue) + step;
        updateTask.isDone = value >= Number(targetValue); // âœ… é‡æ–°è®¡ç®—æ˜¯å¦å®Œæˆ
        updateTask.finValue = `${value}`; // âœ… å…è®¸è¶…è¿‡ç›®æ ‡å€¼
      }

      TaskInfoTableApi.updateDataByDate(updateTask, (res: number) => {
        // âœ… ä¿®æ”¹ï¼šåªæ£€æŸ¥æ•°æ®åº“æ›´æ–°æ˜¯å¦æˆåŠŸï¼Œä¸æ£€æŸ¥æ˜¯å¦å·²å®Œæˆ
        if (!res) {
          Logger.error('taskClock-updateTask', JSON.stringify(res));
          reject(res);
        } else {
          resolve(updateTask);
        }
      })
    })
  }

  updateDayInfo(): Promise<DayInfo> {
    let dayInfo: DayInfo = this.selectedDayInfo.dayInfo;
    dayInfo.finTaskNum += 1;
    dayInfo.targetTaskNum = this.selectedDayInfo.taskList.length;
    return new Promise((resolve, reject) => {
      DayInfoApi.updateData(dayInfo, (res: number) => {
        if (!res) {
          Logger.error('taskClock-updateDayInfo', JSON.stringify(res));
          reject(res);
        }
        Logger.info('taskClock-updateDayInfo', JSON.stringify(dayInfo));
        // åŒæ­¥ç•Œé¢æ•°æ®
        let dayInfoStr = JSON.stringify(dayInfo);
        this.selectedDayInfo.dayInfo = JSON.parse(dayInfoStr);
        resolve(dayInfo);
      });
    });
  }

  updateAchievement(dayInfo: DayInfo): Promise<number> {
    Logger.debug('taskClock-updateAchievement', JSON.stringify(dayInfo));
    return new Promise((resolve, reject) => {
      let preDay = new Date();
      preDay.setDate(preDay.getDate() - 1);
      preDay = new Date(preDay);
      let preDayStr = dateToStr(preDay);
      Logger.info('taskClock-updateAchievement-1', `${preDayStr}`);
      DayInfoApi.query(preDayStr, (res: DayInfo) => {
        Logger.info('taskClock-updateAchievement-2', JSON.stringify(res));
        let isReset = res?.date === '' || res?.targetTaskNum > res?.finTaskNum;
        GlobalInfoApi.query((res: GlobalInfo) => {
          Logger.info('taskClock-globalInfoApi', JSON.stringify(res));
          let achievementInfo = res;
            isReset ? (achievementInfo.checkInDays = 1) : (achievementInfo.checkInDays += 1);
          let isNewAchieve = isReachNewAchievement(achievementInfo);
          let isFirstDaySuccess = achievementInfo.checkInDays === 1 && isNewAchieve;

          if (isNewAchieve) {
            AppStorage.SetOrCreate(ACHIEVEMENT_LEVEL_KEY, achievementInfo.checkInDays);
            achievementInfo.achievements = achievementInfo.achievements + ',' + achievementInfo.checkInDays;
            if (isFirstDaySuccess) {
              console.log('ğŸ‰ æ­å–œï¼é¦–æ¬¡è¿ç»­1å¤©æ‰“å¡æˆåŠŸï¼');
              // è¿™é‡Œå¯ä»¥è§¦å‘ç‰¹æ®Šçš„å¼¹çª—æˆ–åŠ¨ç”»
            }
          }
          // ä¿å­˜åˆ°æ•°æ®åº“
          GlobalInfoApi.updateData(achievementInfo, (res: number) => {
            if (!res) {
              Logger.error('taskClock-updateAchievement', JSON.stringify(res));
              reject(res);
            }
            Logger.debug('taskClock-updateAchievement', JSON.stringify(achievementInfo));
              // isNewAchieve ? resolve(achievementInfo.checkInDays) : resolve(0);
            if (isNewAchieve) {
              console.log(`ğŸ† æ–°æˆå°±è§£é”ï¼šè¿ç»­${achievementInfo.checkInDays}å¤©æ‰“å¡ï¼`);
              resolve(achievementInfo.checkInDays);
            } else {
              resolve(0);
            }
          });
        });
      })
    });
  }
}

